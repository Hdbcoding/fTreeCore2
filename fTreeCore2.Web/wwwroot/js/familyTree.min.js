(function ($, window, undefined) {
    'use strict';
    var canvasApi = window.canvasApi = window.canvasApi || {};
    var defaults = {
        container: '', // container selector
        width: 500,
        height: 500
    };

    var canvases = [];

    //canvas API prototype
    // pwease no steppy on _private fields
    var canvasProto = {
        _init: function (container, width, height) {
            this._container = container;
            this._width = width;
            this._height = height;
            this._$canvas = this._$canvas || $('<canvas>')
                .attr({ width: width, height: height })
                .appendTo(container);
            this._elements = this._elements || [];
            this._ctx = this.ctx || this._$canvas[0].getContext('2d');
            this._offsetX = this._offsetY = 0;
            this._zoomFactor = 1;
        },
        clear: function () {
            //top left corner
            var tl = this.getCoordinates(0,0);
            //bottom right corner
            var br = this.getCoordinates(this._width, this._height);
            var w0 = br.x - tl.x;
            var h0 = br.y - tl.y;

            this._ctx.fillStyle = 'black';
            this._ctx.fillRect(tl.x, tl.y, w0, h0);

            this._ctx.strokeStyle = getRndColor();
            this._ctx.strokeRect(tl.x, tl.y, w0, h0);
        },
        addElement: function (element) {
            if (!this.containsElement(element)) {
                this._elements.push(element);
            }
        },
        removeAllElements: function () {
            //probably too dangerous to keep long term
            this._elements = [];
            this.render();
        },
        removeElement: function (element) {
            var index = this._elements.indexOf(element);
            if (index !== -1) {
                this._elements.splice(index, 1);
            }
        },
        containsElement: function (element) {
            return this._elements.includes(element);
        },
        render: function () {
            this.clear();
            this._elements.forEach(ele => ele.draw(this._ctx));
        },
        getElementsAt: function (x, y) {
            return this._elements.filter(ele => ele.isInBounds(x, y));
        },
        bringToFront: function(element){
            var index = this._elements.indexOf(element);
            var last = this._elements.length - 1;
            if (index != last){
                var old = this._elements[last];
                this._elements[index] = old;
                this._elements[last] = element;
            }
        },
        //ctx transform:
        // a c e
        // b d f
        // 0 0 1
        _transform: function(){
            this._ctx.setTransform(
                this._zoomFactor, 
                0, 
                0, 
                this._zoomFactor, 
                this._offsetX, 
                this._offsetY
            );
        },
        panBy: function (dx, dy) {
            this._offsetX += dx;
            this._offsetY += dy;
            this._transform();
        },
        panTo: function (x, y) {
            this._offsetX = x;
            this._offsetY = y;
            this._transform();
        },
        resetPan: function () {
            this.panTo(0, 0);
        },
        zoom: function(dz, x, y){
            x = x || this._width / 2;
            y = y || this._height / 2;

            this._zoomFactor *= dz;
            this._offsetX = x * (1 - dz) + this._offsetX*dz;
            this._offsetY = y * (1 - dz) + this._offsetY*dz;
            this._transform();
        },
        resetZoom: function () {
            this._zoomFactor = 1;
            this._transform();
        },
        reset: function () {
            this.resetZoom();
            this.resetPan();
        },
        getCoordinates: function (x, y) {
            return this.getScaled(x - this._offsetX, y - this._offsetY);
        },
        getScaled: function(x, y){
            return {
                x: x / this._zoomFactor,
                y: y / this._zoomFactor
            }
        }
    };

    function getRndColor() {
        var r = 255 * Math.random() | 0,
            g = 255 * Math.random() | 0,
            b = 255 * Math.random() | 0;
        return 'rgb(' + r + ',' + g + ',' + b + ')';
    }

    canvasApi.init = function (inputSettings) {
        var settings = $.extend(true, {}, defaults, inputSettings);

        //only one canvas per container. If we've already added a canvas here return the old one
        var old = getCanvas(settings.container);
        if (old) return old;

        //create canvas using the ~~prototype~~
        let instance = Object.create(canvasProto);
        instance._init(settings.container, settings.width, settings.height);
        instance.clear();
        canvases.push(instance);
        return instance;
    }

    function getCanvas(container) {
        for (let i = 0; i < canvases.length; i++) {
            var objInstance = canvases[i];
            if (objInstance._container == container) return objInstance;
        }
        return false;
    }
})($, window);
(function ($, window, undefined) {
    'use strict';
    var visualElement = window.visualElement = window.visualElement || {};

    //new idea - nodes and edges
    //node: {isInBounds, draw, moveBy, moveTo}
    function Node(x, y, w, h, fill, stroke) {
        this._x = x;
        this._y = y;
        this._w = w;
        this._h = h;
        this._fill = fill;
        this._stroke = stroke;
    }

    Node.prototype = {
        isInBounds: function (x, y) {
            return x >= this._x
                && x <= this._x + this._w
                && y >= this._y
                && y <= this._y + this._h;
        },
        draw: function (ctx) {
            ctx.beginPath();
            ctx.rect(this._x, this._y, this._w, this._h);
            ctx.fillStyle = this._fill;
            ctx.fill();
            ctx.strokeStyle = this._stroke;
            ctx.stroke();
            ctx.closePath();
        },
        moveBy: function (dx, dy) {
            this._x += dx;
            this._y += dy;
        },
        moveTo: function (x, y) {
            this._x = x;
            this._y = y;
        }
    }

    visualElement.createNode = function (x = 0, y = 0, w = 50, h = 50, fill = 'white', stroke = 'red') {
        return new Node(x, y, w, h, fill, stroke);
    }

    //edge: {isInBounds, draw, attachA, attachB}
    function Edge(n1, n2, stroke) {
        //concept - an edge is a connection between two nodes
        this._n1 = n1;
        this._n2 = n2;
        this._stroke = stroke;

        this._updateEndpoints();
    }

    Edge.prototype = {
        isInBounds: function (x, y) {
            //concept - an edge has some delta around it where clicks can be registered
            //distance from point to line must be smaller than delta to be a click
            var ep = this.getEndpoints();
            var delta = 10; //random delta, needs calculation
            var d =
                Math.abs((ep.y2 - ep.y1) * x - (ep.x2 - ep.x1) * y + ep.x2 * ep.y1 - ep.y2 - ep.x1)
                / distance(ep.x1, ep.y1, ep.x2, ep.y2);

            return d < delta;
        },
        draw: function (ctx) {
            var ep = this.getEndpoints();
            ctx.beginPath();
            ctx.moveTo(ep.x1, ep.y1);
            ctx.lineTo(ep.x2, ep.y2);
            ctx.strokeStyle = this._stroke;
            ctx.stroke();
            ctx.closePath();
        },
        getEndpoints: function () {
            this._updateEndpoints();
            return {
                x1: this._x1,
                x2: this._x2,
                y1: this._y1,
                y2: this._y2
            }
        },
        _updateNodePositions: function () {
            //updates the cache for node position/size
            //if positions and sizes changed, return true
            var changed = false;

            var newN1 = {
                x: this._n1._x,
                y: this._n1._y,
                w: this._n1._w,
                h: this._n1._h
            };
            var newN2 = {
                x: this._n2._x,
                y: this._n2._y,
                w: this._n2._w,
                h: this._n2._h
            };
            var oldN1 = this._oldN1 || {};
            var oldN2 = this._oldN2 || {};

            if (newN1.x != oldN1.x || newN1.y != oldN2.y
                || newN1.w != oldN1.w || newN1.h != oldN1.h
                || newN2.x != oldN2.x || newN2.y != oldN2.y
                || newN2.w != oldN2.w || newN2.h != oldN2.h)
                changed = true;

            this._oldN1 = newN1;
            this._oldN2 = newN2;
            return changed;
        },
        _updateEndpoints: function () {
            //concept - endpoints can be calculated based on the positions and sizes of the two nodes
            //for now let's just be lazy and do centers
            if (!this._updateNodePositions()) return;

            this._x1 = (2 * this._oldN1.x + this._oldN1.w) / 2
            this._x2 = (2 * this._oldN2.x + this._oldN2.w) / 2
            this._y1 = (2 * this._oldN1.y + this._oldN1.h) / 2
            this._y2 = (2 * this._oldN2.y + this._oldN2.h) / 2
        }
    }

    function distance(x1, y1, x2, y2) {
        //distance between two points
        return Math.sqrt(
            Math.pow(y2 - y1, 2)
            + Math.pow(x2 - x1, 2)
        );
    }

    visualElement.createEdge = function (node1, node2, stroke = 'green') {
        return new Edge(node1, node2, stroke);
    }

})(jQuery, window);
(function ($, window, undefined) {
    'use strict';
    var eventApi = window.eventApi = window.eventApi || {};

    var settings = {
        canvasContainer: '#canvas-container',
        canvasWidth: 1366,
        canvasHeight: 720,
        clear: '#clear',
        zoomIn: '#zoom-in',
        zoomOut: '#zoom-out',
        zoomReset: '#zoom-reset',
        panReset: '#pan-reset'
    }

    eventApi.init = function (overrides) {
        $.extend(true, settings, overrides);

        var canvasInstance = window.canvasApi.init({
            container: settings.canvasContainer,
            height: settings.canvasHeight,
            width: settings.canvasWidth
        });
        canvasInstance.render();

        initBindings(canvasInstance);
    }

    function initBindings(instance) {
        $(settings.clear).on('click', function () {
            instance.removeAllElements();
        });

        $(settings.zoomIn).on('click', function () {
            instance.zoom(1.25);
            instance.render();
        });

        $(settings.zoomOut).on('click', function () {
            instance.zoom(0.8);
            instance.render();
        });

        $(settings.zoomReset).on('click', function () {
            instance.resetZoom();
            instance.render();
        });

        $(settings.panReset).on('click', function () {
            instance.resetPan();
            instance.render();
        });

        instance._$canvas.on('wheel', function (e) {
            var dz = e.originalEvent.deltaY
            var zoom = dz ? dz < 0 ? 1.25 : 0.8 : 1;
            instance.zoom(zoom, e.offsetX, e.offsetY);
            instance.render();
        });


        var isActiveDrag = false;
        var justDragged = false;
        var start = { x: 0, y: 0 };
        var last = { x: 0, y: 0 };
        var current = { x: 0, y: 0 };
        var end = { x: 0, y: 0 };
        var elementsHit = [];
        var topElementHit = false;
        var coords = { x: 0, y: 0 };

        instance._$canvas.on('mousedown', function (e) {
            last = current = start = { x: e.offsetX, y: e.offsetY };
            isActiveDrag = true;
            justDragged = false;

            coords = instance.getCoordinates(start.x, start.y);
            elementsHit = instance.getElementsAt(coords.x, coords.y);
            if (elementsHit.length) {
                topElementHit = elementsHit[0];
            }
        });

        instance._$canvas.on('mousemove', function (e) {
            last = current;
            current = { x: e.offsetX, y: e.offsetY };
            var dx = current.x - last.x;
            var dy = current.y - last.y;
            justDragged = true;
            if (isActiveDrag && topElementHit) {
                //just dragged a thing
                var transform = instance.getScaled(dx, dy);
                topElementHit.moveBy(transform.x, transform.y);
                instance.bringToFront(topElementHit);
                instance.render();
            } else if (isActiveDrag && !topElementHit) {
                //just panned
                instance.panBy(dx, dy);
                instance.render();
            }
        });

        instance._$canvas.on('mouseup', function (e) {
            var end = { x: e.offsetX, y: e.offsetY }
            if (!justDragged) {
                if (topElementHit) {
                    //just clicked a thing
                    console.log(elementsHit);
                } else {
                    //just clicked empty space
                    var ele = window.visualElement.createNode(coords.x, coords.y);
                    instance.addElement(ele);
                    instance.render();
                }
            }

            isActiveDrag = false;
            elementsHit = [];
            topElementHit = false;
        });
    }
})(jQuery, window);