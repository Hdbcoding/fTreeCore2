/**
 * Base canvas functionality, such as panning, zooming, and rendering a set of contained visual elements
 */
(function ($, window, undefined) {
    'use strict';
    var canvasApi = window.canvasApi = window.canvasApi || {};
    var defaults = {
        container: '', // container selector
        width: 500,
        height: 500
    };
    var canvases = [];

    function Canvas(container, width, height) {
        this._container = container;
        this._width = width;
        this._height = height;
        this._$canvas = $('<canvas>')
            .attr({ width: width, height: height })
            .appendTo(container);
        this._ctx = this._$canvas[0].getContext('2d');
        this._nodes = [];
        this._edges = [];
        this._offsetX = this._offsetY = 0;
        this._zoomFactor = 1;
    }
    Canvas.prototype = {
        clear: function () {
            //top left corner
            var tl = this.getCoordinates(0, 0);
            //bottom right corner
            var br = this.getCoordinates(this._width, this._height);
            var w0 = br.x - tl.x;
            var h0 = br.y - tl.y;

            this._ctx.fillStyle = 'black';
            this._ctx.fillRect(tl.x, tl.y, w0, h0);
        },
        addNode: function (n) {
            if (visualElement.isNode(n) && !this.containsNode(n))
                this._nodes.push(n);
        },
        addEdge: function (e) {
            if (visualElement.isEdge(e) && !this.containsEdge(e))
                this._edges.push(e);
        },
        removeAllElements: function () {
            //probably too dangerous to keep long term
            this._nodes = [];
            this._edges = [];
            this.render();
        },
        removeNode: function (node) {
            var nIndex = this._nodes.indexOf(node);
            if (nIndex !== -1) {
                this._nodes.splice(nIndex, 1);
                var edges = this._edges.filter(e => e.isAttachedToNode(node));
                for (let i = 0; i < edges.length; i++) {
                    this.removeEdge(edges[i]);
                }
            }
        },
        removeEdge: function (edge) {
            var eIndex = this._edges.indexOf(edge);
            if (eIndex !== -1) {
                this._edges.splice(eIndex, 1);
                var childEdges = this._edges.filter(n => visualElement.isChildEdge(n) && n.isAttachedToEdge(edge));
                for (let i = 0; i < childEdges.length; i++) {
                    this.removeEdge(childEdges[i]);
                }
            }
        },
        containsNode: function (n) {
            return this._nodes.includes(n);
        },
        containsEdge: function (e) {
            return this._edges.includes(e);
        },
        render: function () {
            this.clear();
            this._edges.forEach(e => e.draw(this._ctx));
            this._nodes.forEach(n => n.draw(this._ctx));
        },
        getElementsAt: function (x, y) {
            var nodesAt = this._nodes.filter(e => e.isInBounds(x, y));
            var edgesAt = this._edges.filter(e => e.isInBounds(x, y));
            return { nodes: nodesAt, edges: edgesAt };
        },
        bringToFront: function (element) {
            var index = this._nodes.indexOf(element);
            var last = this._nodes.length - 1;
            if (index != last) {
                var old = this._nodes[last];
                this._nodes[index] = old;
                this._nodes[last] = element;
            }
        },
        //ctx transform:
        // a c e
        // b d f
        // 0 0 1
        _transform: function () {
            this._ctx.setTransform(
                this._zoomFactor,
                0,
                0,
                this._zoomFactor,
                this._offsetX,
                this._offsetY
            );
        },
        panBy: function (dx, dy) {
            this._offsetX += dx;
            this._offsetY += dy;
            this._transform();
        },
        panTo: function (x, y) {
            this._offsetX = x;
            this._offsetY = y;
            this._transform();
        },
        resetPan: function () {
            this.panTo(0, 0);
        },
        zoom: function (dz, x, y) {
            x = x || this._width / 2;
            y = y || this._height / 2;

            this._zoomFactor *= dz;
            this._offsetX = x * (1 - dz) + this._offsetX * dz;
            this._offsetY = y * (1 - dz) + this._offsetY * dz;
            this._transform();
        },
        resetZoom: function () {
            this._zoomFactor = 1;
            this._transform();
        },
        reset: function () {
            this.resetZoom();
            this.resetPan();
        },
        getCoordinates: function (x, y) {
            return this.getScaled(x - this._offsetX, y - this._offsetY);
        },
        getScaled: function (x, y) {
            return {
                x: x / this._zoomFactor,
                y: y / this._zoomFactor
            }
        }
    };

    //creates an instance of the canvas api, or finds a matching instance, and returns it
    canvasApi.createInstance = function (inputSettings) {
        var settings = $.extend(true, {}, defaults, inputSettings);

        //only one canvas per container. If we've already added a canvas here return the old one
        var old = getInstance(settings.container);
        if (old) return old;

        //create canvas using the ~~prototype~~
        let instance = new Canvas(settings.container, settings.width, settings.height);
        instance.clear();
        canvases.push(instance);
        return instance;
    }

    var getInstance = canvasApi.getInstance = function (container) {
        for (let i = 0; i < canvases.length; i++) {
            var objInstance = canvases[i];
            if (objInstance._container == container) return objInstance;
        }
        return false;
    }
})($, window);
/**
 * Visual elements, such as nodes and edges.
 * elements can be drawn on a canvas with a drawing context
 */
(function ($, window, undefined) {
    'use strict';
    var visualElement = window.visualElement = window.visualElement || {};

    //visual element: all visual elements can be drawn, and can report if they are in bounds
    //these are abstract operations that must be implemented
    var visualElementProto = {
        isInBounds: function () { throw 'abstract base method - implement isInBounds!'; },
        draw: function () { throw 'abstract base method - implement draw!'; }
    }

    //node: A box, with a shape and size, that can be moved around
    function Node(x, y, w, h, fill, stroke) {
        this._x = x;
        this._y = y;
        this._w = w;
        this._h = h;
        this._fill = fill;
        this._stroke = stroke;
    }

    Node.prototype = Object.create(visualElementProto);
    Node.prototype.isInBounds = function (x, y) {
        return x >= this._x
            && x <= this._x + this._w
            && y >= this._y
            && y <= this._y + this._h;
    }
    Node.prototype.draw = function (ctx) {
        ctx.beginPath();
        ctx.rect(this._x, this._y, this._w, this._h);
        ctx.fillStyle = this._fill;
        ctx.fill();
        ctx.strokeStyle = this._stroke;
        ctx.stroke();
        ctx.closePath();
    }
    Node.prototype.moveBy = function (dx, dy) {
        this._x += dx;
        this._y += dy;
    }
    Node.prototype.moveTo = function (x, y) {
        this._x = x;
        this._y = y;
    }
    Node.prototype.getShape = function () {
        return {
            x: this._x,
            y: this._y,
            w: this._w,
            h: this._h
        };
    }

    visualElement.isNode = function (n) {
        return Node.prototype.isPrototypeOf(n);
    }

    visualElement.createNode = function (x = 0, y = 0, w = 50, h = 50, fill = 'white', stroke = 'red') {
        return new Node(x, y, w, h, fill, stroke);
    }

    //base prototype for edges - edges are visual elements that have two endpoints
    //updating endpoints is an abstract operation
    var edgeProto = Object.create(visualElementProto);
    edgeProto.draw = function (ctx) {
        var ep = this.getEndpoints();
        ctx.beginPath();
        ctx.moveTo(ep.x1, ep.y1);
        ctx.lineTo(ep.x2, ep.y2);
        ctx.strokeStyle = this._stroke;
        ctx.stroke();
        ctx.closePath();
    }
    edgeProto.isInBounds = function (x, y) {
        //concept - an edge has some delta around it where clicks can be registered
        //distance from point to line must be smaller than delta to be a click
        var ep = this.getEndpoints();
        var delta = 10; //random delta, needs calculation
        var d = distanceFromLine(ep.x1, ep.y1, ep.x2, ep.y2, x, y);

        return d < delta;
    }
    edgeProto.getEndpoints = function () {
        this.updateEndpoints();
        return {
            x1: this._x1,
            y1: this._y1,
            x2: this._x2,
            y2: this._y2
        }
    }
    edgeProto.updateEndpoints = function () {
        throw 'abstract base method - implement updateEndpoints!';
    }
    edgeProto.isAttachedToNode = function(n) {
        throw 'abstract base method - implement isAttachedToNode!';
    }

    visualElement.isEdge = function(e){
        return edgeProto.isPrototypeOf(e);
    }

    //parentEdge: A line connecting two nodes
    function ParentEdge(n1, n2, stroke) {
        //concept - an edge is a connection between two nodes
        this._n1 = n1;
        this._n2 = n2;
        this._stroke = stroke;

        this.updateEndpoints();
    }

    ParentEdge.prototype = Object.create(edgeProto);
    ParentEdge.prototype.updateEndpoints = function () {
        //concept - endpoints can be calculated based on the positions and sizes of the two nodes
        //for now let's just be lazy and do centers
        if (!this._updateComponentPositions()) return;

        var center1 = centerOfRect(this._oldN1.x, this._oldN1.y, this._oldN1.w, this._oldN1.h);
        this._x1 = center1.x;
        this._y1 = center1.y;
        var center2 = centerOfRect(this._oldN2.x, this._oldN2.y, this._oldN2.w, this._oldN2.h);
        this._x2 = center2.x;
        this._y2 = center2.y;
    }
    ParentEdge.prototype._updateComponentPositions = function () {
        //updates the cache for node position/size
        //if positions and sizes changed, return true
        var changed = false;

        var newN1 = this._n1.getShape();
        var newN2 = this._n2.getShape();
        var oldN1 = this._oldN1 || {};
        var oldN2 = this._oldN2 || {};

        changed = !shapesEqual(newN1, oldN1) || !shapesEqual(newN2, oldN2);

        this._oldN1 = newN1;
        this._oldN2 = newN2;
        return changed;
    }
    ParentEdge.prototype.isAttachedToNode = function(n){
        return n == this._n1 || n == this._n2;
    }

    visualElement.createParentEdge = function (node1, node2, stroke = 'green') {
        return new ParentEdge(node1, node2, stroke);
    }

    //childEdge: a line connecting an edge to a node
    function ChildEdge(e, n, stroke) {
        this._e = e;
        this._n = n;
        this._stroke = stroke;

        this.updateEndpoints();
    }

    ChildEdge.prototype = Object.create(edgeProto);
    ChildEdge.prototype.updateEndpoints = function () {
        //calculate endpoints based on the position and size of the node and edge
        if (!this._updateComponentPositions()) return;

        var center1 = centerOfRect(this._oldN.x, this._oldN.y, this._oldN.w, this._oldN.h);
        this._x1 = center1.x;
        this._y1 = center1.y;
        var center2 = centerOfLine(this._oldE.x1, this._oldE.y1, this._oldE.x2, this._oldE.y2);
        this._x2 = center2.x;
        this._y2 = center2.y;
    }
    ChildEdge.prototype._updateComponentPositions = function () {
        //updates the cache for node position/size
        //if positions and sizes changed, return true
        var changed = false;
        var newN = this._n.getShape();
        var newE = this._e.getEndpoints();
        var oldN = this.oldN || {};
        var oldE = this.oldE || {};

        changed = !shapesEqual(newN, oldN) || !endpointsEqual(newE, oldE);

        this._oldN = newN;
        this._oldE = newE;

        return changed;
    }
    ChildEdge.prototype.isAttachedToNode = function(n){
        return this._n == n;
    }
    ChildEdge.prototype.isAttachedToEdge = function(e){
        return this._e == e;
    }

    visualElement.isChildEdge = function(e){
        return ChildEdge.prototype.isPrototypeOf(e);
    }

    visualElement.createChildEdge = function (edge, node, stroke = 'red') {
        return new ChildEdge(edge, node, stroke);
    }

    //geometry functions
    function distanceBetweenPoints(x1, y1, x2, y2) {
        //distance between two points
        return Math.sqrt(
            Math.pow(y2 - y1, 2)
            + Math.pow(x2 - x1, 2)
        );
    }

    function distanceFromLine(lx1, ly1, lx2, ly2, x, y) {
        return Math.abs((ly2 - ly1) * x - (lx2 - lx1) * y + lx2 * ly1 - ly2 - lx1)
            / distanceBetweenPoints(lx1, ly1, lx2, ly2);
    }

    function centerOfLine(lx1, ly1, lx2, ly2) {
        return { x: (lx1 + lx2) / 2, y: (ly1 + ly2) / 2 };
    }

    function centerOfRect(x, y, w, h) {
        return {
            x: x + w / 2,
            y: y + h / 2
        };
    }

    function shapesEqual(s1, s2) {
        return s1.x == s2.x && s1.y == s2.y
            && s1.w == s2.w && s1.h == s2.h
    }

    function endpointsEqual(ep1, ep2) {
        return ep1.x1 == ep2.x1 && ep1.y1 == ep2.y1
            && ep1.x2 == ep2.x2 && ep1.y2 == ep2.y2
    }

})(jQuery, window);
/**
 * A person has a unique identifier, name, gender, birthdate, and other personal details
 * A person is represented on the canvas by a node
 */
 (function($, window, undefined){
     'use strict';
     var person = window.person = window.person || {};
 })(jQuery, window);
/**
 * A relationship contains two parent persons, and a collection of child persons
 * A relationship is represented by an edge between the parent nodes,
 *  and a collection of edges between the parent-edge and all children edges
 */
(function ($, window, undefined) {
    'use strict';
    var familyNode = window.familyNode = window.familyNode || {};

    function Relationship(dad, mom, kids) {
        this._dad = dad;
        this._mom = mom;
        this._kids = kids;

        this._createParentEdge();
        this._createKidEdges();
    }

    Relationship.prototype = {
        _createParentEdge: function () {
            this._parentEdge = visualElement.createParentEdge(this._dad.getNode(), this._mom.getNode());
        },
        _createKidEdges: function (){
            var edges = [];
            this._kids.forEach((kid) => {
                edges.push(visualElement.createChildEdge(this._parentEdge, kid.getNode()));
            });
            this._kidEdges = edges;
        },
    }

})(jQuery, window);
/**
 * user interaction events, to interact with the canvas and manipulate the family tree
 */
(function ($, window, undefined) {
    'use strict';
    var familyApi = window.familyApi = window.familyApi || {};
    var defaults = {
        container: '#canvas-container',
        width: 1366,
        height: 720,
        clear: '.clear',
        zoomIn: '.zoom-in',
        zoomOut: '.zoom-out',
        zoomReset: '.zoom-reset',
        panReset: '.pan-reset'
    };
    var families = [];

    function Family(container, width, height){
        this._container = container;
        this._canvas = canvasApi.createInstance({
            container: container, width: width, height: height
        });
        this._people = [];
        this._relationships = [];

        createCanvasControls(this);
        createFamilyControls(this);
        initBindings(this);
    }

    familyApi.createInstance = function (overrides) {
        var settings = $.extend(true, {}, defaults, overrides);

        //only one family per container
        var old = getInstance(settings.container);
        if (old) return old;

        let instance = new Family(settings.container, settings.width, settings.height);
        return instance;
    }

    var getInstance = familyApi.getInstance = function(container){
        for (let i = 0; i < families.length; i++) {
            var objInstance = families[i];
            if (objInstance._container == container) return objInstance;
        }
        return false;
    }

    function createCanvasControls(family){
        var $container = $(family._container);
        var $controls = $('<div>',{class:'canvas-controls'}).appendTo($container);

        $('<button>', {class: 'zoom-in'}).text('+').appendTo($controls);
        $('<button>', {class: 'zoom-out'}).text('-').appendTo($controls);
        $('<button>', {class: 'zoom-reset'}).text('Reset zoom').appendTo($controls);
        $('<button>', {class: 'pan-reset'}).text('Reset pan').appendTo($controls);
    }

    function createFamilyControls(family){
        var $container = $(family._container);
        var $controls = $('<div>',{class:'family-controls'}).appendTo($container);

        $('<button>', {class: 'clear'}).text('Clear canvas').appendTo($controls);
    }

    function initBindings(family) {
        var $container = $(family._container);
        var $canvas = family._canvas._$canvas;

        $container.on('click', defaults.clear, function () {
            family._canvas.removeAllElements();
        });

        $container.on('click', defaults.zoomIn, function () {
            family._canvas.zoom(1.25);
            family._canvas.render();
        });

        $container.on('click', defaults.zoomOut, function () {
            family._canvas.zoom(0.8);
            family._canvas.render();
        });

        $container.on('click', defaults.zoomReset, function () {
            family._canvas.resetZoom();
            family._canvas.render();
        });

        $container.on('click', defaults.panReset, function () {
            family._canvas.resetPan();
            family._canvas.render();
        });

        $canvas.on('wheel', function (e) {
            var dz = e.originalEvent.deltaY
            var zoom = dz ? dz < 0 ? 1.25 : 0.8 : 1;
            family._canvas.zoom(zoom, e.offsetX, e.offsetY);
            family._canvas.render();
        });

        var isActiveDrag = false;
        var justDragged = false;
        var start = { x: 0, y: 0 };
        var last = { x: 0, y: 0 };
        var current = { x: 0, y: 0 };
        var end = { x: 0, y: 0 };
        var elementsHit = [];
        var topNodeHit = false;
        var coords = { x: 0, y: 0 };

        $canvas.on('mousedown', function (e) {
            last = current = start = { x: e.offsetX, y: e.offsetY };
            isActiveDrag = true;
            justDragged = false;

            coords = family._canvas.getCoordinates(start.x, start.y);
            elementsHit = family._canvas.getElementsAt(coords.x, coords.y);
            if (elementsHit.nodes.length){
                topNodeHit = elementsHit.nodes[0];
            }
        });

        $canvas.on('mousemove', function (e) {
            last = current;
            current = { x: e.offsetX, y: e.offsetY };
            var dx = current.x - last.x;
            var dy = current.y - last.y;
            justDragged = true;
            if (isActiveDrag && topNodeHit) {
                //just dragged a thing
                var transform = family._canvas.getScaled(dx, dy);
                topNodeHit.moveBy(transform.x, transform.y);
                family._canvas.bringToFront(topNodeHit);
                family._canvas.render();
            } else if (isActiveDrag && !topNodeHit) {
                //just panned
                family._canvas.panBy(dx, dy);
                family._canvas.render();
            }
        });

        $canvas.on('mouseup', function (e) {
            var end = { x: e.offsetX, y: e.offsetY }
            if (!justDragged) {
                if (topNodeHit) {
                    //just clicked a thing
                    console.log(elementsHit);
                } else {
                    //just clicked empty space
                    var n = visualElement.createNode(coords.x, coords.y);
                    family._canvas.addNode(n);
                    family._canvas.render();
                }
            }

            isActiveDrag = false;
            elementsHit = [];
            topNodeHit = false;
        });
    }
})(jQuery, window);