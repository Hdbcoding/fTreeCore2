(function ($, window, undefined) {
    'use strict';
    var canvasApi = window.canvasApi = window.canvasApi || {};
    var defaults = {
        container: '', // container selector
        width: 500,
        height: 500
    };

    var canvases = [];

    //canvas API prototype
    // pwease no steppy on _private fields
    var canvasProto = {
        _init: function (container, width, height) {
            this._container = container;
            this._width = width;
            this._height = height;
            this._$canvas = this._$canvas || $('<canvas>')
                .attr({ width: width, height: height })
                .appendTo(container);
            this._elements = this._elements || [];
            this._ctx = this.ctx || this._$canvas[0].getContext('2d');
            this._offsetX = this._offsetY = 0;
            this._zoomFactor = 1;

            this._$canvas.on('click', function(e){
                console.log(e.offsetX, e.offsetY);
            });
        },
        clear: function () {
            this._ctx.fillStyle = 'black';
            this._ctx.fillRect(-this._offsetX, -this._offsetY, this._width, this._height);
        },
        addElement: function (element) {
            if (!this.containsElement(element)) {
                this._elements.push(element);
            }
        },
        removeElement: function (element) {
            var index = this._elements.indexOf(element);
            if (index !== -1) {
                this._elements.splice(index, 1);
            }
        },
        containsElement: function(element){
            return this._elements.includes(element);
        },
        render: function () {
            this.clear();
            for (let i = 0; i < this._elements.length; i++) {
                this._elements[i].draw(this._ctx);
            }
        },
        //ctx transform:
        // a c e
        // b d f
        // 0 0 1
        panBy: function (dx, dy) {
            this._offsetX += dx;
            this._offsetY += dy;
            this._ctx.transform(1, 0, 0, 1, dx, dy);
        },
        panTo: function (x, y) {
            this._offsetX = x;
            this._offsetY = y;
            this._ctx.setTransform(this._zoomFactor, 0, 0, this._zoomFactor, x, y);
        },
        resetPan: function () {
            this.panTo(0, 0);
        },
        zoomBy: function (df) {
            this._zoomFactor *= df;
            this._ctx.transform(1 * df, 0, 0, 1 * df, 0, 0);
        },
        zoomTo: function (factor) {
            this._zoomFactor = factor;
            this._ctx.setTransform(factor, 0, 0, factor, this._offsetX, this._offsetY);
        },
        resetZoom: function () {
            this.zoomTo(1);
        },
        reset: function(){
            this.resetZoom();
            this.resetPan();
        }
    };

    canvasApi.init = function (inputSettings) {
        var settings = $.extend(true, {}, defaults, inputSettings);

        //only one canvas per container. If we've already added a canvas here return the old one
        var old = getCanvas(settings.container);
        if (old) return old;

        //create canvas using the ~~prototype~~
        let instance = Object.create(canvasProto);
        instance._init(settings.container, settings.width, settings.height);
        instance.clear();
        canvases.push(instance);
        return instance;
    }

    function getCanvas(container) {
        for (let i = 0; i < canvases.length; i++) {
            var objInstance = canvases[i];
            if (objInstance._container == container) return objInstance;
        }
        return false;
    }
})($, window);
(function ($, window, undefined) {
    'use strict';
    var visualElement = window.visualElement = window.visualElement || {};
    var defaults = {
        x: 0,
        y: 0,
        width: 50,
        height: 50,
        drawOptions: {
            fillStyle: 'white',
            strokeStyle: 'red',
        },
        drawCallback: drawRect
    };

    var elementProto = {
        _init: function (x, y, width, height, drawOptions, drawCallback) {
            this._x = x;
            this._y = y;
            this._width = width;
            this._height = height;
            this._drawOptions = drawOptions;
            this._drawCallback = drawCallback;
        },
        draw: function (ctx) {
            if ($.isFunction(this._drawCallback)) this._drawCallback(ctx);
            else drawRect.call(this, ctx);
        },
        moveBy: function (dx, dy) {
            this._x += dx;
            this._y += dy;
        },
        moveTo: function (x, y) {
            this._x = x;
            this._y = y;
        }
    };

    visualElement.createElement = function (inputSettings) {
        var settings = $.extend(true, {}, defaults, inputSettings);
        var instance = Object.create(elementProto);
        instance._init(settings.x, settings.y, settings.width, settings.height, settings.drawOptions, settings.drawCallback);
        return instance;
    }

    //rectangles - used to hold people
    var rectProto = {

    }
    visualElement.createRect = function (inputSettings) {
        return visualElement.createElement($.extend(true, {}, inputSettings, { drawCallback: drawRect }));
    }

    var drawRect = function (ctx) {
        ctx.beginPath();
        ctx.rect(this._x, this._y, this._width, this._height);
        ctx.fillStyle = this._drawOptions.fillStyle;
        ctx.fill();
        ctx.strokeStyle = this._drawOptions.strokeStyle;
        ctx.stroke();
        ctx.closePath();
    }

    //lines - connecting people to eachother
    //may need a different prototype for lines, since they have different interactivity requirements
    visualElement.createLine = function (inputSettings) {
        var dO = inputSettings.drawOptions
        var x = Math.min(dO.x1, dO.x2);
        var y = Math.min(dO.y1, dO.y2);
        var width = Math.abs(dO.x1 - dO.x2);
        var height = Math.abs(dO.y1 - dO.y2);
        var settings = $.extend(true,
            { x: x, y: y, width: width, height: height },
            inputSettings,
            { drawCallback: drawLine });
        return visualElement.createElement(settings);
    }

    var drawLine = function (ctx) {
        ctx.beginPath();
        ctx.moveTo(this._drawOptions.x1, this._drawOptions.y1);
        ctx.lineTo(this._drawOptions.x2, this._drawOptions.y2);
        ctx.strokeStyle = this._drawOptions.strokeStyle;
        ctx.stroke();
        ctx.closePath();
    }


    //new idea - nodes and edges
    //node: {isInBounds, draw, moveBy, moveTo}
    //edge: {isInBounds, draw, attachA, attachB}
    function Node(x, y, w, h, fill, stroke) {
        this._x = x;
        this._y = y;
        this._w = w;
        this._h = h;
        this._fill = fill;
        this._stroke = stroke;
    }

    Node.prototype = {
        isInBounds: function (x, y) {
            return x >= this._x
                && x <= this._x + this._w
                && y >= this._y
                && y <= this._y + this._h;
        },
        draw: function (ctx) {
            ctx.beginPath();
            ctx.rect(this._x, this._y, this._w, this._h);
            ctx.fillStyle = this._fill;
            ctx.fill();
            ctx.strokeStyle = this._stroke;
            ctx.stroke();
            ctx.closePath();
        },
        moveBy: function (dx, dy) {
            this._x += dx;
            this._y += dy;
        },
        moveTo: function (x, y) {
            this._x = x;
            this._y = y;
        }
    }

    visualElement.createNode = function (x = 0, y = 0, w = 50, h = 50, fill = 'white', stroke = 'red') {
        return new Node(x, y, w, h, fill, stroke);
    }

    function Edge(n1, n2, stroke){
        //concept - an edge is a connection between two nodes
        this._n1 = n1;
        this._n2 = n2;
        this._stroke = stroke;
    }

    Edge.prototype = {
        isInBounds: function(x, y){
            //concept - an edge has some delta around it where clicks can be registered
            //distance from point to line must be smaller than delta to be a click
            var ep = this.getEndpoints();
            var delta = 10; //random delta, needs calculation
            var d = 
                Math.abs((ep.y2 - ep.y1)*x - (ep.x2-ep.x1)*y + ep.x2*ep.y1 - ep.y2 - ep.x1) 
                / distance(ep.x1, ep.y1, ep.x2, ep.y2);

            return d < delta;
        },
        draw: function(ctx){
            var ep = this.getEndpoints();
            ctx.beginPath();
            ctx.moveTo(ep.x1, ep.y1);
            ctx.lineTo(ep.x2, ep.y2);
            ctx.strokeStyle = this._stroke;
            ctx.stroke();
            ctx.closePath();
        },
        getEndpoints: function(){
            //concept - endpoints can be calculated based on the positions and sizes of the two nodes
            //for now let's just be lazy and do centers
            return {
                x1: (2*this._n1._x + this._n1._w) / 2,
                x2: (2*this._n2._x + this._n2._w) / 2,
                y1: (2*this._n1._y + this._n1._h) / 2,
                y2: (2*this._n2._y + this._n2._h) / 2
            }
        }
    }

    function distance(x1, y1, x2, y2){
        //distance between two points
        return Math.sqrt(
            Math.pow(y2 - y1,2) 
            + Math.pow(x2 - x1,2)
        );
    }

    visualElement.createEdge = function(node1, node2, stroke = 'green'){
        return new Edge(node1, node2, stroke);
    }

})(jQuery, window);